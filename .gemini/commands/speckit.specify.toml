description = "根据自然语言功能描述创建或更新功能规范。"

prompt = """
---
description: 根据自然语言功能描述创建或更新功能规范。
handoffs:
    - label: 构建技术计划
      agent: speckit.plan
      prompt: 为规范制定计划。我正在构建...
    - label: 澄清规范需求
      agent: speckit.clarify
      prompt: 澄清规范需求
      send: true
---

## 语言要求

-   生成的规范内容 (`spec.md`) **必须**使用中文(简体)书写。
-   文件路径、命令、代码片段和专有技术名称保持原样。

## 开发原则

-   **KISS**: 保持简单 (Keep It Simple, Stupid)。优先考虑最简单的实现。
-   **DRY**: 不要重复自己 (Don't Repeat Yourself)。避免重复的逻辑。
-   **SOLID**: 遵守单一职责、开闭、里氏替换、接口隔离和依赖倒置原则。
-   **YAGNI**: 你不会需要它 (You Ain't Gonna Need It)。仅实现明确要求的内容。

## 用户输入

```text
$ARGUMENTS
```

如果用户输入不为空，你**必须**在继续之前考虑它。

## 大纲

用户在 `/speckit.specify` 之后输入的文本**就是**功能描述。假设你在这次对话中总是有它，即使 `$ARGUMENTS` 在下面按字面显示。除非用户提供空命令，否则不要要求用户重复它。

鉴于该功能描述，请执行以下操作：

1. **为功能目录生成简洁的短名称**(2-4 个词)：

    - 分析功能描述并提取最有意义的关键字
    - 创建一个捕捉功能本质的 2-4 个词的短名称
    - 尽可能使用动名词格式(例如，"add-user-auth", "fix-payment-bug")
    - 保留技术术语和首字母缩略词(OAuth2, API, JWT 等)
    - 保持简洁但足够描述性，以便一眼就能理解功能
    - 示例：
        - "I want to add user authentication" → "user-auth"
        - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
        - "Create a dashboard for analytics" → "analytics-dashboard"
        - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. **确定功能上下文和编号**:
    a. 首先，尝试获取远程信息(如果在 git 仓库中)以确保 ID 唯一性：

    ```bash
    git fetch --all --prune 2>/dev/null || true
    ```

    b. 查找所有来源中的最大功能编号(以避免冲突)：

    - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`(如果 git 可用)
    - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`(如果 git 可用)
    - 规格目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录

    c. 确定下一个可用编号：

    - 从所有可用来源提取所有编号
    - 找到最大编号 N
    - 使用 N+1 作为新功能标识符

    d. 使用计算出的编号和短名称运行脚本 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"`：

    - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
    - Bash 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
    - PowerShell 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

    **重要**:

    - 目标是建立唯一的**功能上下文**(文件夹 `specs/NNN-name`)。
    - 检查所有来源(远程/本地/文件夹)以查找最大编号，防止 ID 冲突。
    - 每个功能只能运行此脚本一次。
    - JSON 输出将包含 `BRANCH_NAME`(充当功能 ID)和 `SPEC_FILE` 路径。
    - 此脚本初始化目录结构，但**不**自动强制 git 分支。
    - 对于像 "I'm Groot" 这样的参数中的单引号，请使用转义语法：例如 'I\\'m Groot'(或者如果可能，使用双引号："I'm Groot")。

3. 加载 `.specify/templates/spec-template.md` 以了解所需部分。

4. **遵循此执行流程(结合 MCP 工具增强质量)**：

#### MCP 使用要求

在生成规范内容时，应积极利用集成工具以提高准确性和深度：

-   **默认调用顺序(本命令内)**：
-   1. `sequential-thinking`(推演业务流程/边缘情况)→ 2) `context7`(外部基准/合规约束)→ 3) `serena`(术语一致性/查重，严格受限)。
-   如果任一 MCP 工具不可用：必须在规范的"假设/成功标准/备注"相关位置增加一条显式注释，说明缺失工具、原因、替代信息源与潜在风险(不得静默跳过)。

-   **Sequential Thinking**：
-   用于**解析用户描述**和**构建用户场景**。
-   必须用于分解复杂的业务逻辑，识别隐藏的边缘情况(Edge Cases)，并确保逻辑链条的完整性。

-   **Context7**：
-   用于**设定成功标准**和**填补默认值**。
-   当需要设定性能指标或合规性约束时，搜索行业标准(如"2024 年电商结账平均时间"或"GDPR 数据保留要求")，确保指标客观、现实且有据可依。
-   若引用了外部基准：必须在规范相应小节附近附上"来源记录"(URL + 版本/发布日期 + 摘要 1 句)，以便后续审阅。

-   **Serena (严格受限模式)**：
-   仅用于**检查业务术语一致性**(例如：现有规范称其为 "Client" 还是 "Customer"？)或**查重**。
-   **严禁**使用 Serena 提取任何实现细节(包括但不限于：src/ 代码、API 结构、技术栈、数据库/表结构、框架约定)。规范必须保持技术中立。

#### 执行步骤

    1. 从输入解析用户描述
       如果为空：报错 "No feature description provided"
    2. 从描述中提取关键概念
       识别：参与者、动作、数据、约束
    3. 对于不清楚的方面：
       - 根据上下文和行业标准进行有根据的猜测
       - 仅在以下情况下使用 [NEEDS CLARIFICATION: specific question] 标记：
         - 选择显着影响功能范围或用户体验
         - 存在多种具有不同含义的合理解释
         - 不存在合理的默认值
       - **限制：总共最多 3 个 [NEEDS CLARIFICATION] 标记**
       - 按影响对澄清进行优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写用户场景和测试部分
       如果没有清晰的用户流程：报错 "Cannot determine user scenarios"
    5. 生成功能需求
       每个需求必须是可测试的
       对未指定的细节使用合理的默认值(在假设部分记录假设)
    6. 定义成功标准
       创建可衡量的、技术无关的结果
       包括定量指标(时间、性能、数量)和定性指标(用户满意度、任务完成率)
       每个标准必须在不知道实施细节的情况下可验证
    7. 识别关键实体(如果涉及数据)
    8. 返回：SUCCESS(规范已准备好进行规划)

5. 使用模板结构将规范写入 SPEC_FILE，用从功能描述(参数)派生的具体细节替换占位符，同时保留部分顺序和标题。

6. **规范质量验证**: 编写初始规范后，根据质量标准对其进行验证：

   a. **创建规范质量核查清单**: 使用核查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成核查清单文件，包含这些验证项目：

      ```markdown
      # 规范质量核查清单: [功能名称]

      **目的**: 在进行规划之前验证规范的完整性和质量
      **创建时间**: [日期]
      **功能**: [spec.md 链接]

      ## 内容质量

      - [ ] 无实施细节(语言、框架、API)
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有强制性部分已完成

      ## 需求完整性

      - [ ] 没有剩余的 [NEEDS CLARIFICATION] 标记
      - [ ] 需求可测试且明确
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关(无实施细节)
      - [ ] 所有验收场景已定义
      - [ ] 边缘情况已识别
      - [ ] 范围界定清晰
      - [ ] 依赖项和假设已识别

      ## 功能准备就绪

      - [ ] 所有功能需求都有清晰的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 功能符合成功标准中定义的可衡量结果
      - [ ] 没有实施细节泄漏到规范中

      ## 备注

      - 标记为未完成的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规范
      ```

   b. **运行验证检查**: 针对每个核查清单项目审查规范：
      - 对于每个项目，确定是通过还是失败
      - 记录发现的具体问题(引用相关规范部分)

   c. **处理验证结果**:

      - **如果所有项目通过**: 标记核查清单完成并继续执行步骤 6

      - **如果项目失败(不包括 [NEEDS CLARIFICATION])**:
        1. 列出失败的项目和具体问题
        2. 更新规范以解决每个问题
        3. 重新运行验证直到所有项目通过(最多 3 次迭代)
        4. 如果在 3 次迭代后仍然失败，在核查清单备注中记录剩余问题并警告用户

      - **如果保留 [NEEDS CLARIFICATION] 标记**:
        1. 从规范中提取所有 [NEEDS CLARIFICATION: ...] 标记
        2. **限制检查**: 如果存在超过 3 个标记，仅保留 3 个最关键的(按范围/安全/UX 影响)，并对其余部分进行有根据的猜测
        3. 对于每个需要的澄清(最多 3 个)，按以下格式向用户提供选项：

           ```markdown
           ## 问题 [N]: [主题]

           **上下文**: [引用相关规范部分]

           **我们需要知道什么**: [来自 NEEDS CLARIFICATION 标记的具体问题]

           **建议答案**:

           | 选项 | 答案 | 含义 |
           |------|------|------|
           | A    | [第一个建议答案] | [这对功能意味着什么] |
           | B    | [第二个建议答案] | [这对功能意味着什么] |
           | C    | [第三个建议答案] | [这对功能意味着什么] |
           | Custom | 提供您自己的答案 | [解释如何提供自定义输入] |

           **您的选择**: _[等待用户响应]_
           ```

        4. **关键 - 表格格式化**: 确保 markdown 表格格式正确：
           - 使用一致的间距，管道对齐
           - 每个单元格内容周围应有空格：`| Content |` 而不是 `|Content|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 测试表格在 markdown 预览中正确呈现
        5. 按顺序编号问题(Q1, Q2, Q3 - 总共最多 3 个)
        6. 在等待响应之前将所有问题一起提出
        7. 等待用户对所有问题的选择(例如，"Q1: A, Q2: Custom - [details], Q3: B")
        8. 通过用用户选择或提供的答案替换每个 [NEEDS CLARIFICATION] 标记来更新规范
        9. 在所有澄清解决后重新运行验证

   d. **更新核查清单**: 每次验证迭代后，更新核查清单文件以反映当前的通过/失败状态

7. 报告完成，包括功能名称、规范文件路径、核查清单结果以及下一阶段(`/speckit.clarify` 或 `/speckit.plan`)的准备就绪状态。

**注意:** 该脚本初始化规范目录结构，但不强制 git 分支检出，允许灵活的工作流。

## 通用指南

## 快速指南

- 关注用户需要**什么**以及**为什么**。
- 避免**如何**实施(无技术栈、API、代码结构)。
- 为业务利益相关者而非开发人员编写。
- **不要**创建嵌入在规范中的任何核查清单。那将是一个单独的命令。

### 部分要求

- **强制性部分**: 每个功能都必须完成
- **可选部分**: 仅当与功能相关时包含
- 当部分不适用时，将其完全删除(不要保留为 "N/A")

### 用于 AI 生成

当根据用户提示创建此规范时：

1. **做出有根据的猜测**: 使用上下文、行业标准和常见模式来填补空白
2. **记录假设**: 在假设部分记录合理的默认值
3. **限制澄清**: 最多 3 个 [NEEDS CLARIFICATION] 标记 - 仅用于以下关键决策：
   - 显着影响功能范围或用户体验
   - 具有多种具有不同含义的合理解释
   - 缺乏任何合理的默认值
4. **优先考虑澄清**: 范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试员一样思考**: 每个模糊的需求都应无法通过“可测试且明确”的核查清单项目
6. **需要澄清的常见领域**(仅当不存在合理的默认值时)：
   - 功能范围和边界(包含/排除特定用例)
   - 用户类型和权限(如果可能有多种相互冲突的解释)
   - 安全/合规要求(在法律/财务上很重要时)

**合理默认值的示例**(不要询问这些)：

- 数据保留：该领域的行业标准做法
- 性能目标：除非另有说明，否则为标准 Web/移动应用预期
- 错误处理：具有适当回退的用户友好消息
- 身份验证方法：Web 应用的标准基于会话或 OAuth2
- 集成模式：除非另有说明，否则为 RESTful API

### 成功标准指南

成功标准必须是：

1. **可衡量的**: 包括具体指标(时间、百分比、计数、比率)
2. **技术无关**: 不提及框架、语言、数据库或工具
3. **以用户为中心**: 从用户/业务角度描述结果，而不是系统内部
4. **可验证**: 无需知道实施细节即可测试/验证

**好的示例**:

- "用户可以在 3 分钟内完成结帐"
- "系统支持 10,000 个并发用户"
- "95% 的搜索在 1 秒内返回结果"
- "任务完成率提高 40%"

**坏的示例**(关注实施)：

- "API 响应时间低于 200ms"(太技术化，使用“用户立即看到结果”)
- "数据库每秒可处理 1000 个事务"(实施细节，使用面向用户的指标)
- "React 组件渲染高效"(特定于框架)
- "Redis 缓存命中率高于 80%"(特定于技术)
"""
