<!-- OPENSPEC:START -->
# OpenSpec 指令

这些指令是为在本项目中工作的 AI 助手准备的。

当请求涉及以下内容时，请始终打开 `@/openspec/AGENTS.md`：
- 提及规划或提案（如 proposal、spec、change、plan 等词汇）
- 引入新功能、破坏性变更、架构转变或重要的性能/安全工作
- 听起来含糊不清，需要在编码前获得权威规范

使用 `@/openspec/AGENTS.md` 来学习：
- 如何创建和应用变更提案
- 规范格式和约定
- 项目结构和指南

保留此托管块，以便 'openspec update' 可以刷新指令。

<!-- OPENSPEC:END -->

# CLAUDE.md

此文件为 Claude Code (claude.ai/code) 在此代码库中工作时提供指导。

## 项目概述

**YiVideo** 是一个基于动态工作流引擎和微服务架构构建的 AI 驱动视频处理平台。核心理念是"配置优于编码"——AI 处理流水线通过工作流配置文件动态构建。

### 核心功能

-   **自动语音识别 (ASR)**：由 Faster-Whisper 驱动的高精度语音转文本
-   **说话人分离**：使用 Pyannote-audio 进行多说话人识别和分离
-   **光学字符识别 (OCR)**：通过 PaddleOCR 进行字幕区域检测和文本识别
-   **音频处理**：人声/背景音分离和音频增强
-   **字幕处理**：AI 驱动的字幕生成、校对、优化和合并
-   **文本转语音 (TTS)**：多引擎高质量语音合成
-   **视频处理**：基于 FFmpeg 的视频编辑和格式转换

## 项目结构

```
yivideo/
├── services/                    # 微服务目录
│   ├── api_gateway/             # API 网关 - 统一入口点
│   ├── common/                  # 公共模块（状态管理、工具）
│   └── workers/                 # Celery 工作器服务
│       ├── faster_whisper_service/   # ASR 语音识别
│       ├── pyannote_audio_service/   # 说话人分离
│       ├── paddleocr_service/        # OCR 文本识别
│       ├── audio_separator_service/  # 音频分离
│       ├── ffmpeg_service/           # 视频处理
│       ├── indextts_service/         # TTS 语音合成
│       ├── gptsovits_service/        # GPT-SoVITS TTS
│       ├── inpainting_service/       # 视频修复
│       └── wservice/                 # 通用工作流服务
├── config/                      # 配置文件
├── config.yml                   # 主配置文件
├── docker-compose.yml           # 容器编排
├── docs/                        # 项目文档
├── openspec/                    # OpenSpec 规范
├── tests/                       # 测试目录
├── share/                       # 服务间共享存储
└── scripts/                     # 实用脚本
```

## 技术栈

### 后端框架与服务

-   **Python 3.8+**：主要编程语言
-   **FastAPI**：API 网关的 HTTP 服务框架
-   **Celery 5.x**：分布式任务队列和工作流引擎
-   **Redis**：多用途数据存储（DB0：代理，DB1：后端，DB2：锁，DB3：状态）

### AI/ML 模型与库

-   **Faster-Whisper**：GPU 加速语音识别
-   **Pyannote-audio**：说话人分离和声纹识别
-   **PaddleOCR**：中英文 OCR 识别
-   **Audio-Separator**：音频源分离
-   **IndexTTS / GPT-SoVITS**：TTS 引擎

### 基础设施

-   **Docker & Docker Compose**：容器化部署
-   **FFmpeg**：音视频处理
-   **MinIO**：对象存储服务
-   **CUDA 11.x+**：GPU 加速支持

## 开发命令

```
# 容器管理
docker-compose up -d              # 启动所有服务
docker-compose ps                 # 检查服务状态
docker-compose logs -f <service>  # 查看日志

# 测试
pytest tests/unit/                # 单元测试
pytest tests/integration/         # 集成测试
pytest -m gpu                     # GPU 测试
```

## 全局架构约束

**关键**：所有代码生成、重构和设计任务都必须严格遵循这些原则。

### 1. KISS（保持简单，愚蠢）

-   **规则**：优先选择最简单的实现路径。避免过度工程化。
-   **触发**：如果代码需要复杂的注释来解释，或者对简单逻辑使用设计模式（如策略/工厂模式）。
-   **指令**："如果简单的 `if/else` 就能工作，就不要使用复杂的模式。"保持认知负荷低。

### 2. DRY（不要重复自己）

-   **规则**：每段逻辑都必须有单一、明确的表示。
-   **触发**：重复的逻辑块、复制的代码或重复的魔法值。
-   **指令**：将重复的逻辑提取到实用函数或常量中。_注意：避免损害可读性的过早抽象。_

### 3. YAGNI（你不会需要它）

-   **规则**：仅实现当前规范/任务中明确要求的内容。
-   **触发**：为未来功能添加"钩子"、未使用的配置选项或额外的接口方法。
-   **指令**："只编写通过当前测试所需的代码。"不要推测未来的需求。

### 4. SOLID（面向对象设计）

-   **SRP**：单一职责原则（只有一个变更理由）。
-   **OCP**：开闭原则（扩展而不修改）。
-   **LSP**：里氏替换原则（子类型必须可替换）。
-   **ISP**：接口隔离原则（不强制依赖未使用的方法）。
-   **DIP**：依赖反转原则（依赖抽象）。

### 违规检查（自我纠正）

在输出任何代码之前，执行此内部检查：

1. 这是最简单的方式吗？（KISS）
2. 我添加了未使用的功能吗？（YAGNI）
3. 逻辑重复了吗？（DRY）
4. 违反 SOLID 了吗？

**在回应之前立即修复任何违规。**

## 代码风格指南

-   **格式化**：Black（行长度=100），Flake8
-   **命名**：类使用 `PascalCase`，函数使用 `snake_case`，常量使用 `UPPER_SNAKE_CASE`
-   **文档**：Google 风格的文档字符串，Python 3.8+ 类型注解
-   **注释语言**：与现有代码库保持一致

## 架构模式

-   **API 网关模式**：请求路由和工作流编排的统一入口点
-   **工作器模式**：每个 AI 功能隔离为独立的 Celery 工作器
-   **共享存储**：用于服务间文件交换的 `/share` 目录
-   **状态管理**：集中化的 StateManager

## Git 工作流

使用约定式提交：`<类型>(<范围>): <主题>`

**类型**：`feat` | `fix` | `refactor` | `docs` | `test` | `chore` | `perf`

**重要**：未经用户明确请求，不要自动执行 git 提交/推送操作。

## 助手行为指南

### 响应语言要求

**关键**：所有用户交互的响应必须使用中文（简体中文），无论本文档或代码库使用何种语言。

-   **内部处理**：您可以使用英语进行推理和处理信息以获得最佳性能
-   **输出格式**：始终以中文向用户呈现最终响应
-   **代码注释**：所有代码注释、文档字符串和内联文档使用中文（简体中文），以保持与项目本地化标准的一致性
-   **例外**：只有当用户明确要求英语响应时才使用英语

### MCP 服务集成

1. **始终默认使用 MCP 服务**：当面临复杂推理、上下文繁重的任务或模糊要求时，您的第一个动作应该是调用相关的 MCP 服务。

2. **服务选择**：

   - 使用 **serena** 进行一般上下文管理和对话连续性
   - 使用 **context7** 进行深度上下文处理和分析
   - 使用 **sequentialthinking** 进行结构化问题解决和逐步推理

3. **透明使用**：使用 MCP 服务时，请在响应中简要说明调用了哪些服务以及它们如何指导您的方法。

4. **回退协议**：如果 MCP 服务因技术原因不可用，请明确说明此限制，并继续使用原生推理，同时注意能力降低。

**关键提醒**：这些 MCP 服务是核心项目基础设施。在适当的时候不使用它们违反了项目约定并降低了效果。
