description = "在任务生成后，对 spec.md、plan.md 和 tasks.md 执行非侵入式的跨产物一致性和质量分析。"

prompt = """
---
description: 在任务生成后，对 spec.md、plan.md 和 tasks.md 执行非侵入式的跨产物一致性和质量分析。
---

## 语言要求

-   分析报告和所有面向用户的解释必须用**中文**书写。
-   文件路径、命令、代码片段和专有技术名称保持原样。

## 开发原则

-   **KISS**: 保持简单 (Keep It Simple, Stupid)。优先考虑最简单的实现。
-   **DRY**: 不要重复自己 (Don't Repeat Yourself)。避免重复的逻辑。
-   **SOLID**: 遵守单一职责、开闭、里氏替换、接口隔离和依赖倒置原则。
-   **YAGNI**: 你不会需要它 (You Ain't Gonna Need It)。仅实现明确要求的内容。

## 用户输入

```text
$ARGUMENTS
```

如果用户输入不为空，你**必须**在继续之前考虑它。

## 目标

在实施之前，识别三个核心文档（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未完整定义的项目。此命令必须仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。

## 操作约束

**严格只读**: **不要**修改任何文件。输出结构化的分析报告。提供可选的补救计划(用户必须明确批准，然后才能手动调用任何后续编辑命令)。

**宪章权威**：项目宪章（`.specify/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为"严重"，需要调整规范、计划或任务——而不是弱化、重新解释或忽略该原则。如果原则本身需要更改，那是 `/speckit.analyze` 之外的单独、显式宪章更新。

## MCP 使用要求 (只读增强)

-   允许使用 MCP 仅用于"提高定位与判断质量"，不得改变本命令的只读属性：
-   1. `sequential-thinking`：用于构建语义模型、归因与严重性分配的一致推理链(输出仍需紧凑、≤50 发现)。
-   2. `serena`：只用于定位仓库中的文件/符号/引用与术语漂移证据(例如 tasks 引用的路径是否存在、同概念是否多名)，**严禁**写入或自动修复。
-   3. `context7`(可选)：仅当"建议"部分引用外部标准/最佳实践时使用，并在建议中附最小来源记录(避免把主观偏好包装成权威)。

## 执行步骤

### 1. 初始化分析上下文

从仓库根目录运行一次 `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果缺少任何必需文件，则通过错误消息中止(指示用户运行缺少的先决条件命令)。
对于像 "I'm Groot" 这样的参数中的单引号，请使用转义语法：例如 'I\\'m Groot'(或者如果可能，使用双引号："I'm Groot")。

### 2. 加载产物(渐进式披露)

从每个产物中仅加载必要的最小上下文：

**从 spec.md:**

- 概述/上下文
- 功能需求
- 非功能需求
- 用户故事
- 边缘情况(如果存在)

**从 plan.md:**

- 架构/技术栈选择
- 数据模型引用
- 阶段
- 技术约束

**从 tasks.md:**

- 任务 ID
- 描述
- 阶段分组
- 并行标记 [P]
-引用的文件路径

**从宪章:**

- 加载 `.specify/memory/constitution.md` 进行原则验证

### 3. 构建语义模型

创建内部表示(不要在输出中包含原始产物)：

- **需求清单**: 每个功能 + 非功能需求都有一个稳定的键(基于祈使短语派生 slug；例如，"User can upload file" → `user-can-upload-file`)
- **用户故事/动作清单**: 具有验收标准的离散用户动作
- **任务覆盖映射**: 将每个任务映射到一个或多个需求或故事(通过关键字/显式引用模式(如 ID 或关键短语)进行推断)
- **宪章规则集**: 提取原则名称和 MUST/SHOULD 规范性陈述

### 4. 检测过程(高效 Token 分析)

关注高信号发现。总共限制 50 个发现；将其余部分汇总在溢出摘要中。

#### A. 重复检测

- 识别近似重复的需求
- 标记低质量措辞以进行合并

#### B. 歧义检测

- 标记缺乏可衡量标准的模糊形容词(快速、可扩展、安全、直观、健壮)
- 标记未解决的占位符(TODO, TKTK, ???, `<placeholder>` 等)

#### C. 说明不足

- 有动词但缺少对象或可衡量结果的需求
- 缺少验收标准对齐的用户故事
- 任务引用了未在规范/计划中定义的组件或文件

#### D. 宪章一致性

- 任何需求或计划元素与 MUST 原则冲突
- 缺少宪章规定的部分或质量门槛

#### E. 覆盖缺口

- 零关联任务的需求
- 没有映射需求/故事的任务
- 任务中未反映的非功能需求(例如，性能、安全)

#### F. 不一致

- 术语漂移(同一概念在不同文件中名称不同)
- 计划中引用但在规范中缺失的数据实体(反之亦然)
- 任务顺序矛盾(例如，集成任务在基础设置任务之前，且没有依赖说明)
- 需求冲突(例如，一个要求 Next.js，而另一个指定 Vue)

### 5. 严重性分配

使用此启发式方法确定发现的优先级：

- **CRITICAL (严重)**: 违反宪章 MUST 原则，缺少核心规范产物，或零覆盖的需求阻碍了基线功能
- **HIGH (高)**: 重复或冲突的需求，模糊的安全/性能属性，不可测试的验收标准
- **MEDIUM (中)**: 术语漂移，缺少非功能任务覆盖，未说明的边缘情况
- **LOW (低)**: 风格/措辞改进，不影响执行顺序的轻微冗余

### 6. 生成紧凑分析报告

输出 Markdown 报告(不写入文件)，结构如下：

## 规范分析报告

| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |
|----|------|--------|------|------|------|
| A1 | 重复 | HIGH | spec.md:L120-134 | 两个类似的需求... | 合并措辞；保留更清晰的版本 |

(每个发现添加一行；生成以类别首字母为前缀的稳定 ID。)

**覆盖率摘要表:**

| 需求键 | 有任务? | 任务 ID | 备注 |
|--------|---------|---------|------|

**宪章一致性问题:** (如果有)

**未映射任务:** (如果有)

**指标:**

- 总需求数
- 总任务数
- 覆盖率 % (>=1 个任务的需求)
- 歧义计数
- 重复计数
- 严重问题计数

### 7. 提供下一步行动

在报告末尾，输出简洁的“下一步行动”块：

- 如果存在 CRITICAL 问题：建议在 `/speckit.implement` 之前解决
- 如果仅有 LOW/MEDIUM 问题：用户可以继续，但提供改进建议
- 提供明确的命令建议：例如，“运行 /speckit.specify 进行细化”，“运行 /speckit.plan 调整架构”，“手动编辑 tasks.md 以添加对 'performance-metrics' 的覆盖”

### 8. 提供补救措施

询问用户：“您是否希望我为前 N 个问题建议具体的补救编辑？”(**不要**自动应用它们。)

## 操作原则

### 上下文效率

- **最少的高信号 Token**: 关注可操作的发现，而不是详尽的文档
- **渐进式披露**: 增量加载产物；不要将所有内容倾倒到分析中
- **高效 Token 输出**: 将发现表限制为 50 行；总结溢出部分
- **确定性结果**: 在没有更改的情况下重新运行应产生一致的 ID 和计数

### 分析指南

- **绝不修改文件** (这是只读分析)
- **绝不产生幻觉** (如果缺少部分，准确报告)
- **优先考虑宪章违规** (这些总是 CRITICAL)
- **使用示例而非详尽规则** (引用具体实例，而不是通用模式)
- **优雅地报告零问题** (通过覆盖率统计数据发出成功报告)

## 上下文

$ARGUMENTS
"""
