# 参数获取函数迁移指南

> **版本**: v1.0
> **最后更新**: 2025-11-22

## 1. 简介

为了解决各服务节点参数获取逻辑不一致、难以维护以及单任务模式下参数丢失的问题，我们引入了统一的参数获取函数 `get_param_with_fallback`。本指南旨在帮助开发者了解该函数的使用方法，并指导如何将旧代码迁移到新标准。

## 2. 核心函数 `get_param_with_fallback`

该函数位于 `services.common.parameter_resolver` 模块中。

```python
def get_param_with_fallback(
    param_name: str,
    resolved_params: Dict[str, Any],
    workflow_context: Union[WorkflowContext, Dict[str, Any]],
    default: Any = None,
    fallback_from_input_data: bool = True,
    fallback_from_stage: Optional[str] = None,
    fallback_field: Optional[str] = None,
    allow_dynamic_resolution: bool = True
) -> Any:
```

### 参数说明

- `param_name`: (必需) 参数名称，例如 "video_path"。
- `resolved_params`: (必需) 已经过 `resolve_parameters` 处理的节点参数字典。
- `workflow_context`: (必需) 工作流上下文对象。
- `default`: (可选) 如果所有来源都找不到参数，返回的默认值。默认为 `None`。
- `fallback_from_input_data`: (可选) 是否尝试从 `input_data` (单任务输入) 获取。默认为 `True`。
- `fallback_from_stage`: (可选) 上游阶段的名称。如果指定，将在最后尝试从该阶段的输出中获取。
- `fallback_field`: (可选) 在上游阶段输出中查找的字段名。如果不指定，默认使用 `param_name`。
- `allow_dynamic_resolution`: (可选) 是否允许对 `input_data` 中的字符串值进行 `${{...}}` 动态引用解析。默认为 `True`。

### 获取优先级

函数严格按照以下顺序查找参数：

1.  **`resolved_params`**: 显式配置在工作流 `node_params` 中的参数（优先级最高）。
2.  **`input_data`**: 单任务模式下传入的参数（支持动态引用）。
3.  **`upstream_stage`**: 指定的上游阶段输出（如果配置了 `fallback_from_stage`）。
4.  **`default`**: 默认值。

## 3. 迁移步骤

### 场景 1: 简单的全局参数 (如 `video_path`)

**旧代码:**
```python
video_path = resolved_params.get("video_path")
if not video_path:
    video_path = workflow_context.input_params.get("input_data", {}).get("video_path")
```

**新代码:**
```python
from services.common.parameter_resolver import get_param_with_fallback

video_path = get_param_with_fallback("video_path", resolved_params, workflow_context)
```

### 场景 2: 带默认值的参数 (如 `batch_size`)

**旧代码:**
```python
batch_size = resolved_params.get("batch_size", 32)
```

**新代码:**
```python
# 现在也支持从 input_data 覆盖默认值
batch_size = get_param_with_fallback(
    "batch_size", 
    resolved_params, 
    workflow_context, 
    default=32
)
```

### 3. 场景 3: 依赖上游输出的参数 (如 `subtitle_area`)

**旧代码:**
```python
crop_area = resolved_params.get("subtitle_area")
if not crop_area:
    prev_stage = workflow_context.stages.get('paddleocr.detect_subtitle_area')
    if prev_stage and prev_stage.output:
        crop_area = prev_stage.output.get("subtitle_area")
```

**新代码:**
```python
crop_area = get_param_with_fallback(
    "subtitle_area",
    resolved_params,
    workflow_context,
    fallback_from_stage="paddleocr.detect_subtitle_area"
)
```

### 场景 4: 复杂的多级回退 (如 `audio_path`)

如果需要从多个上游节点回退，可以链式调用或多次调用。

**新代码:**
```python
# 1. 尝试从参数或 input_data 获取
audio_path = get_param_with_fallback("audio_path", resolved_params, workflow_context)

# 2. 尝试从 audio_separator 获取
if not audio_path:
    audio_path = get_param_with_fallback(
        "vocal_audio",  # 上游字段名
        resolved_params,
        workflow_context,
        fallback_from_stage="audio_separator.separate_vocals",
        fallback_from_input_data=False # 避免重复检查 input_data
    )

# 3. 尝试从 ffmpeg 获取
if not audio_path:
    audio_path = get_param_with_fallback(
        "audio_path",
        resolved_params,
        workflow_context,
        fallback_from_stage="ffmpeg.extract_audio",
        fallback_from_input_data=False
    )
```

## 4. 最佳实践

1.  **始终导入**: 在所有 Celery 任务文件中导入 `get_param_with_fallback`。
2.  **替换所有**: 即使旧逻辑看起来能工作，也建议替换为新函数，以获得 `input_data` 动态解析等额外好处。
3.  **明确默认值**: 如果参数不是必需的，务必提供 `default` 值。
4.  **清理旧代码**: 移除冗余的 `if/else` 判断和手动字典查找代码。

## 5. 常见问题

**Q: `input_data` 中的参数支持动态引用吗？**
A: 支持。如果 `input_data` 中的值是 `${{...}}` 格式的字符串，新函数会自动尝试解析它。

**Q: 如何获取布尔值参数？**
A: 直接使用即可。`default=False` 可以确保在未找到时返回布尔值。

**Q: 性能会受影响吗？**
A: 影响微乎其微。函数内部只有简单的字典查找和字符串解析，开销极低。
